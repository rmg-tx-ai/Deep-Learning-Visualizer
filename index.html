<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        /* Modern Reset & Base */
        * { box-sizing: border-box; }
        
        body { 
            margin: 0; 
            display: flex; 
            height: 100vh; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            overflow: hidden; 
            background: #111; 
            color: #eee;
            transition: background 0.3s, color 0.3s; 
        }

        /* Sidebar Container */
        #sidebar { 
            width: 340px; 
            padding: 32px 24px; 
            background: #111; 
            border-right: 1px solid #222; 
            display: flex; 
            flex-direction: column; 
            gap: 24px; 
            overflow-y: auto; 
            flex-shrink: 0;
        }

        /* Canvas Container */
        #canvas-container { 
            flex-grow: 1; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            background: #000; 
            transition: background 0.3s; 
        }

        /* Typography & Layout Utils */
        .control-group { 
            display: flex; 
            flex-direction: column; 
            gap: 10px; 
        }

        label { 
            font-size: 11px; 
            font-weight: 600; 
            text-transform: uppercase; 
            letter-spacing: 0.05em; 
            color: #888; 
            transition: color 0.3s; 
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Value Display */
        span[id$="-val"], #seedValue { 
            font-family: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace; 
            color: #00d2ff; 
            font-size: 11px; 
            background: rgba(0, 210, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* Inputs */
        input[type="range"] { 
            -webkit-appearance: none;
            width: 100%; 
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #eee;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            border: 2px solid #111;
        }

        select { 
            width: 100%; 
            padding: 10px 12px; 
            background: #222; 
            color: #eee; 
            border: 1px solid #333; 
            border-radius: 6px; 
            font-size: 13px; 
            cursor: pointer; 
            transition: all 0.2s; 
            appearance: none; /* Removes default arrow */
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23888888%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 12px top 50%;
            background-size: 10px auto;
            margin-bottom: 8px; /* Added spacing to balance visual weight against sliders */
        }
        select:hover { border-color: #555; }
        select:focus { border-color: #00d2ff; outline: none; }

        input[type="color"] { 
            -webkit-appearance: none;
            width: 100%; 
            border: none; 
            height: 36px; 
            cursor: pointer; 
            background: transparent; 
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 1px solid #333; border-radius: 6px; }

        /* Buttons */
        button { 
            padding: 10px 16px; 
            cursor: pointer; 
            background: transparent; 
            color: #eee; 
            border: 1px solid #333; 
            border-radius: 6px; 
            font-size: 13px; 
            font-weight: 500;
            transition: all 0.2s; 
        }
        button:hover { background: #222; border-color: #555; }

        .seed-controls { display: flex; gap: 8px; }
        .seed-controls button { flex: 1; padding: 8px; font-size: 12px; }

        .btn-primary {
            background: #eee;
            color: #111;
            border: 1px solid #eee;
            font-weight: 600;
            margin-top: auto; /* Push to bottom if space allows */
        }
        .btn-primary:hover { background: #fff; border-color: #fff; box-shadow: 0 0 10px rgba(255,255,255,0.2); }

        /* Instructions */
        .instruction { 
            font-size: 12px; 
            color: #666; 
            padding: 12px; 
            background: #1a1a1a; 
            border-radius: 6px;
            border: 1px solid #222;
            line-height: 1.5;
        }

        /* Light Theme Styles */
        body.light-theme { background: #fff; color: #111; }
        body.light-theme #sidebar { background: #fff; border-right: 1px solid #e5e5e5; }
        body.light-theme #canvas-container { background: #fafafa; }
        body.light-theme label { color: #666; }
        
        body.light-theme button { background: #fff; color: #333; border-color: #e5e5e5; }
        body.light-theme button:hover { background: #f5f5f5; border-color: #ccc; }
        
        body.light-theme select { background-color: #fff; color: #333; border-color: #e5e5e5; }
        body.light-theme select:hover { border-color: #ccc; }
        
        body.light-theme input[type="range"] { background: #e5e5e5; }
        body.light-theme input[type="range"]::-webkit-slider-thumb { background: #fff; border-color: #ccc; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        
        body.light-theme span[id$="-val"], body.light-theme #seedValue { color: #0077aa; background: rgba(0, 119, 170, 0.1); }
        body.light-theme input[type="color"]::-webkit-color-swatch { border: 1px solid #e5e5e5; }
        body.light-theme .instruction { background: #f9f9f9; border-color: #e5e5e5; color: #666; }

        body.light-theme .btn-primary { background: #0077aa; color: #fff; border-color: #0077aa; }
        body.light-theme .btn-primary:hover { background: #006699; border-color: #006699; box-shadow: 0 2px 8px rgba(0, 119, 170, 0.3); }
    </style>
</head>
<body class="light-theme">
    <div id="sidebar">
        <div class="control-group">
            <button onclick="toggleTheme()" id="theme-btn">Switch to Dark Mode</button>
        </div>

        <div class="control-group">
            <label>Seed <span id="seedValue"></span></label>
            <div class="seed-controls">
                <button onclick="updateSeed(currentSeed - 1)">Prev</button>
                <button onclick="updateSeed(currentSeed + 1)">Next</button>
                <button onclick="updateSeed(Math.floor(Math.random()*99999))">Random</button>
            </div>
        </div>
        
        <div class="instruction">
            <strong>Interactive 3D View</strong><br>
            Click & Drag to Rotate<br>
            Scroll to Zoom
        </div>

        <div id="params-container"></div>

        <button onclick="saveArt()" class="btn-primary">Download PNG</button>
    </div>
    
    <div id="canvas-container"></div>

    <script>
    // --- YOUR GENERATIVE ART CODE GOES HERE ---
    
    // 1. DEFINE PARAMETERS
    let params = {
        architecture: { value: "Linear", type: "select", options: ["Linear", "Spherical", "Helix", "Torus"], name: "Topology" },
        layerCount: { value: 6, min: 3, max: 12, step: 1, name: "Network Depth" },
        nodeDensity: { value: 8, min: 4, max: 15, step: 1, name: "Layer Width" },
        zSpread: { value: 200, min: 50, max: 500, step: 10, name: "Z-Depth Spread" },
        synapseDensity: { value: 0.6, min: 0.1, max: 1.0, step: 0.05, name: "Connection Density" },
        pulseSpeed: { value: 3.5, min: 0.5, max: 10.0, step: 0.5, name: "Transmission Speed" },
        chaos: { value: 0.2, min: 0.0, max: 1.0, step: 0.05, name: "Latent Chaos" },
        energyBloom: { value: 15, min: 0, max: 50, step: 1, name: "Energy Bloom" },
        themeColor: { value: "#00d2ff", type: "color", name: "Start Color" },
        secondaryColor: { value: "#ff00ff", type: "color", name: "End Color" }
    };

    let currentSeed = 12345;
    let layers = [];
    let pulses = [];
    let isDarkMode = false;
    
    function toggleTheme() {
        isDarkMode = !isDarkMode;
        if (isDarkMode) {
            document.body.classList.remove('light-theme');
            document.getElementById('theme-btn').innerText = "Switch to Light Mode";
        } else {
            document.body.classList.add('light-theme');
            document.getElementById('theme-btn').innerText = "Switch to Dark Mode";
        }
    }

    // Classes for the Neural Architecture
    class Node {
        constructor(x, y, z, layerIndex, id) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.baseX = x;
            this.baseY = y;
            this.baseZ = z;
            this.layerIndex = layerIndex;
            this.id = id;
            this.activation = 0;
            this.size = random(3, 8); // Slightly smaller for 3D
        }

        update(time) {
            // "Latent Chaos" makes nodes drift slightly in 3D feature space
            let noiseScale = 0.02;
            let drift = params.chaos.value * 20;
            
            // 3D Noise Drift
            this.x = this.baseX + (noise(time * 0.5, this.y * noiseScale, this.z * noiseScale) - 0.5) * drift;
            this.y = this.baseY + (noise(this.x * noiseScale, time * 0.5, this.z * noiseScale) - 0.5) * drift;
            this.z = this.baseZ + (noise(this.x * noiseScale, this.y * noiseScale, time * 0.5) - 0.5) * drift;
            
            // Decay activation
            this.activation *= 0.92;
        }

        draw(c1, c2, totalLayers) {
            // Calculate gradient color based on layer index
            let amt = this.layerIndex / (totalLayers - 1);
            let myColor = lerpColor(c1, c2, amt);

            let r = red(myColor);
            let g = green(myColor);
            let b = blue(myColor);
            
            push();
            translate(this.x, this.y, this.z);
            noStroke();
            
            // Adjust alpha and brightness based on mode
            let baseAlpha = isDarkMode ? 100 : 180;
            let bloomAlphaMult = isDarkMode ? 1 : 1.5; // Make bloom stronger in light mode to be visible
            
            // Core
            let brightness = map(this.activation, 0, 1, baseAlpha, 255);
            fill(r, g, b, brightness);
            sphere(this.size);
            
            // 3D "Bloom" - Simulated by a larger transparent sphere
            if (params.energyBloom.value > 0 && this.activation > 0.05) {
                let bloomSize = this.size * 2 + (params.energyBloom.value * 0.5 * this.activation);
                fill(r, g, b, this.activation * 30 * bloomAlphaMult); // Low alpha
                sphere(bloomSize);
                
                // Second halo for intense activation
                if(this.activation > 0.5) {
                    fill(r, g, b, this.activation * 40 * bloomAlphaMult);
                    sphere(this.size * 1.5);
                }
            }
            
            // White Hot Core flash (Only in dark mode does it go pure white, light mode stays saturated)
            if (this.activation > 0.2) {
                if (isDarkMode) {
                    fill(255, 255, 255, this.activation * 200);
                } else {
                    fill(r, g, b, this.activation * 200); // Saturated core in light mode
                }
                sphere(this.size * 0.6);
            }
            pop();
        }
        
        trigger() {
            this.activation = 1.0;
        }
    }

    class Synapse {
        constructor(startNode, endNode, weight) {
            this.start = startNode;
            this.end = endNode;
            this.weight = weight;
        }

        draw(c1, c2, totalLayers) {
            // Calculate color based on the START node's layer
            let amt = this.start.layerIndex / (totalLayers - 1);
            let myColor = lerpColor(c1, c2, amt);

            let r = red(myColor);
            let g = green(myColor);
            let b = blue(myColor);
            
            // Darker lines in light mode for contrast
            let lineScalar = isDarkMode ? 0.6 : 0.8; 
            
            strokeWeight(this.weight * 1.0);
            stroke(r * lineScalar, g * lineScalar, b * lineScalar, isDarkMode ? 40 : 60); 
            
            line(this.start.x, this.start.y, this.start.z, this.end.x, this.end.y, this.end.z);
        }
    }

    class Pulse {
        constructor(synapse) {
            this.synapse = synapse;
            this.progress = 0;
            this.speed = random(0.01, 0.03) * params.pulseSpeed.value;
            this.active = true;
            this.trail = [];
        }

        update() {
            this.progress += this.speed;
            
            // Calculate current position (3D Interpolation)
            let cx = lerp(this.synapse.start.x, this.synapse.end.x, this.progress);
            let cy = lerp(this.synapse.start.y, this.synapse.end.y, this.progress);
            let cz = lerp(this.synapse.start.z, this.synapse.end.z, this.progress);
            
            // Add to trail
            this.trail.push({x: cx, y: cy, z: cz, p: this.progress});
            if (this.trail.length > 8) this.trail.shift();

            // Check arrival
            if (this.progress >= 1) {
                this.synapse.end.trigger();
                this.active = false;
                
                // Chance to propagate forward if not last layer
                if (this.synapse.end.layerIndex < layers.length - 1) {
                   attemptPropagation(this.synapse.end);
                }
            }
        }

        draw(c1, c2, totalLayers) {
            // Calculate base gradient for the start and end of this specific hop
            let layerAmtStart = this.synapse.start.layerIndex / (totalLayers - 1);
            let layerAmtEnd = this.synapse.end.layerIndex / (totalLayers - 1);

            // Draw the data packet
            for (let i = 0; i < this.trail.length; i++) {
                let t = this.trail[i];
                let size = map(i, 0, this.trail.length, 1, 3);
                let alpha = map(i, 0, this.trail.length, 0, 255);
                
                let globalAmt = lerp(layerAmtStart, layerAmtEnd, t.p);
                let myColor = lerpColor(c1, c2, globalAmt);

                push();
                translate(t.x, t.y, t.z);
                noStroke();
                fill(red(myColor), green(myColor), blue(myColor), alpha);
                sphere(size * this.synapse.weight);
                pop();
            }
        }
    }

    function setup() {
        // Use WEBGL for 3D
        let cnv = createCanvas(windowWidth - 300, windowHeight, WEBGL);
        cnv.parent('canvas-container');
        generateUI();
        loop(); 
        initArchitecture();
    }

    function windowResized() {
        resizeCanvas(windowWidth - 300, windowHeight);
        initArchitecture();
    }

    function initArchitecture() {
        randomSeed(currentSeed);
        noiseSeed(currentSeed);
        
        layers = [];
        pulses = [];
        
        let cols = params.layerCount.value;
        let topology = params.architecture.value;
        
        // Bounds helpers
        let rangeX = width * 0.6;
        let startX = -rangeX / 2;
        let stepX = rangeX / (cols - 1);
        let rangeY = height * 0.6;
        let rangeZ = params.zSpread.value;

        // 1. Build Nodes (The Architecture)
        for (let i = 0; i < cols; i++) {
            let layerNodes = [];
            let count = Math.floor(params.nodeDensity.value * random(0.8, 1.2));
            if (i === 0 || i === cols - 1) count = Math.floor(count * 0.6); 
            
            for (let j = 0; j < count; j++) {
                let x, y, z;
                
                if (topology === "Linear") {
                    x = startX + (i * stepX);
                    y = random(-rangeY/2, rangeY/2);
                    z = random(-rangeZ, rangeZ);
                } 
                else if (topology === "Spherical") {
                    // Layers form expanding shells from center
                    // Input layer (0) is inner core, Output is outer shell
                    let radius = map(i, 0, cols-1, 50, rangeY/2);
                    // Distribute uniformly on sphere surface using golden spiral or just random trig
                    let theta = random(0, TWO_PI);
                    let phi = acos(random(-1, 1));
                    
                    x = radius * sin(phi) * cos(theta);
                    y = radius * sin(phi) * sin(theta);
                    z = radius * cos(phi);
                }
                else if (topology === "Helix") {
                    // Double Helix (DNA style)
                    let helixRadius = rangeX / 6; 
                    let turns = 2.5; // More turns for a taller strand feel
                    
                    // Calculate base angle for this layer
                    let baseAngle = map(i, 0, cols-1, -PI, PI * turns);
                    let yPos = map(i, 0, cols-1, rangeY/2, -rangeY/2); // Bottom to top
                    
                    // Split nodes into two opposing strands (Double Helix)
                    // We use modulo 2 on the node index 'j' to alternate sides
                    let strandOffset = (j % 2 === 0) ? 0 : PI;
                    let theta = baseAngle + strandOffset;
                    
                    x = helixRadius * cos(theta) + random(-10, 10);
                    z = helixRadius * sin(theta) + random(-10, 10);
                    y = yPos + random(-5, 5);
                }
                else if (topology === "Torus") {
                    // Ring architecture
                    let majorRadius = rangeX / 2.5;
                    let tubeRadius = rangeX / 8;
                    
                    // Map layers around the major ring (0 to 2PI)
                    let majorAngle = map(i, 0, cols-1, 0, TWO_PI * 0.85); // 0.85 leaves a small gap for visual clarity of start/end
                    let minorAngle = random(0, TWO_PI); // Random position inside the tube cross-section
                    
                    // Torus parametric equation
                    x = (majorRadius + tubeRadius * cos(minorAngle)) * cos(majorAngle);
                    z = (majorRadius + tubeRadius * cos(minorAngle)) * sin(majorAngle);
                    y = tubeRadius * sin(minorAngle);
                }

                layerNodes.push(new Node(x, y, z, i, j));
            }
            layers.push(layerNodes);
        }

        // 2. Build Synapses
        for (let i = 0; i < layers.length - 1; i++) {
            let currentLayer = layers[i];
            let nextLayer = layers[i + 1];
            
            for (let node of currentLayer) {
                node.outgoing = [];
                for (let nextNode of nextLayer) {
                    if (random() < params.synapseDensity.value) {
                        let weight = random(0.5, 2.5);
                        let synapse = new Synapse(node, nextNode, weight);
                        node.outgoing.push(synapse);
                    }
                }
            }
        }
    }
    
    function attemptPropagation(node) {
        if (!node.outgoing || node.outgoing.length === 0) return;
        
        for (let synapse of node.outgoing) {
            if (random() < 0.4) {
                pulses.push(new Pulse(synapse));
            }
        }
    }

    function draw() {
        // Theme switching logic
        if (isDarkMode) {
            background(10, 15, 20);
            blendMode(ADD); 
        } else {
            background(250, 250, 252);
            blendMode(BLEND); // Multiply or Blend works best on light backgrounds
        }
        
        // --- 3D INTERACTION ---
        orbitControl(); 
        
        let c1 = color(params.themeColor.value);
        let c2 = color(params.secondaryColor.value);

        let t = frameCount * 0.01;
        let totalL = layers.length;
        
        // 1. Draw Connections (Lines)
        for (let i = 0; i < totalL; i++) {
            for (let node of layers[i]) {
                node.update(t);
                if (node.outgoing) {
                    for (let synapse of node.outgoing) {
                        synapse.draw(c1, c2, totalL);
                    }
                }
            }
        }

        // 2. Manage Inputs
        if (frameCount % 10 === 0) {
            let inputLayer = layers[0];
            let randomInput = random(inputLayer);
            randomInput.trigger();
            attemptPropagation(randomInput);
        }

        // 3. Draw Pulses
        for (let i = pulses.length - 1; i >= 0; i--) {
            pulses[i].update();
            pulses[i].draw(c1, c2, totalL);
            if (!pulses[i].active) {
                pulses.splice(i, 1);
            }
        }

        // 4. Draw Nodes (Spheres)
        for (let i = 0; i < totalL; i++) {
            for (let node of layers[i]) {
                node.draw(c1, c2, totalL);
            }
        }
        
        // Reset blend mode at end of frame
        blendMode(BLEND);
    }

    // --- INFRASTRUCTURE ---
    function generateUI() {
        const container = document.getElementById('params-container');
        container.innerHTML = ''; 
        for (let key in params) {
            let p = params[key];
            let div = document.createElement('div');
            div.className = 'control-group';
            
            if (p.type === 'color') {
                div.innerHTML = `<label>${p.name} <span id="${key}-val">${p.value}</span></label>
                             <input type="color" value="${p.value}" 
                             oninput="updateParam('${key}', this.value)">`;
            } else if (p.type === 'select') {
                let opts = p.options.map(o => `<option value="${o}" ${o === p.value ? 'selected' : ''}>${o}</option>`).join('');
                div.innerHTML = `<label>${p.name}</label>
                                 <select onchange="updateParam('${key}', this.value)">${opts}</select>`;
            } else {
                div.innerHTML = `<label>${p.name} <span id="${key}-val">${p.value}</span></label>
                             <input type="range" min="${p.min}" max="${p.max}" step="${p.step}" value="${p.value}" 
                             oninput="updateParam('${key}', this.value)">`;
            }
            container.appendChild(div);
        }
        updateSeed(currentSeed);
    }

    function updateParam(key, val) {
        if (params[key].type === 'color' || params[key].type === 'select') {
            params[key].value = val;
        } else {
            params[key].value = parseFloat(val);
        }
        
        if (params[key].type !== 'select') {
            document.getElementById(`${key}-val`).innerText = val;
        }
        
        if (key !== 'themeColor' && key !== 'secondaryColor' && key !== 'chaos' && key !== 'energyBloom' && key !== 'pulseSpeed') {
             initArchitecture();
        }
    }

    function updateSeed(newSeed) {
        currentSeed = newSeed;
        document.getElementById('seedValue').innerText = currentSeed;
        initArchitecture();
    }
    
    function saveArt() { 
        save('luminescent_connectionism.png'); 
    }
    </script>
</body>
</html>
